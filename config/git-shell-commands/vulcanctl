#!/bin/bash

# vulcanctl
#
# Vulcan control script to be packaged with the Vulcan forge container
#
# James Jenkins 2025
#
# TODO: long help messages/manpage, repo rename/edit commands, auth add command

# Global vars
USAGE="vulcanctl [-h | --help] <command> [<args>]"
GIT_DIR="/home/git"

# GP functions
die() {
        # Quits with exit code and print message if provided
        local status=$1
        local message=$2
        [[ "$message" ]] && echo "$message"
        exit $status
}

confirm() {
        # Confirms dangerous stuff
        local prompt="$1"

        # call with a prompt string or use a default
        read -p "${prompt} [N/y]: " -r        
        case "$REPLY" in
                [yY][eE][sS]|[yY]) 
                        true
                        ;;
                *)
                        die 0 "Cancelled."
                        ;;
        esac
}

assert_repo_exists() {
        # Asserts that the reponame exists in the git dir
        local path="$GIT_DIR/${1}.git"
        [ ! -d "$path" ] && die 1 "No such repository: $path"
}

assert_repo_no_exists() {
        # Asserts that the reponame does not exist in the git dir
        local path="$GIT_DIR/${1}.git"
        [ -d "$path" ] && die 1 "Repository exists: $path"
}

# Repo functions
repo_list() {
        # Pretty prints a list of stored repositories 
        # FIXME do the pretty part
        ls $GIT_DIR
}

repo_init() {
        # Handles repo subcommand init
        local repo="$1"
        assert_repo_no_exists "$repo"
        local path="$GIT_DIR/${repo}.git"
        
        mkdir "$path"
        cd "$path"
        git init --bare
}

repo_rm() {
        # Handles repo subcommand rm
        local repo="$1"
        assert_repo_exists "$repo"
        local path="$GIT_DIR/${repo}.git"

        confirm "Really delete repository ${repo}? This CANNOT be undone." && \
        confirm "The repository ${repo} will be gone FOREVER. Is this OK?" && \
        rm -rf "$path"
}


repo_open() {
        # Opens a repo 
        # FIXME check repo already open
        local repo="$1"
        assert_repo_exists "$repo"
        local path="$GIT_DIR/${repo}.git"

        confirm "Really open ${repo}? The repository will be visible on gitweb and readable without authentication." && \
        confirm "Again, the repository will be readable to the outside world WITHOUT any authentication. Is this OK?" && \
        touch "$path/git-daemon-export-ok"
}

repo_close() {
        # Closes a repo 
        # FIXME check repo already closed
        local repo="$1"
        assert_repo_exists "$repo"
        local path="$GIT_DIR/${repo}.git"

        confirm "Really close ${repo}?" && \
        rm "$path/git-daemon-export-ok"
}

repo() {
        # Handles "repo" subcommand
        local repo_usage="vulcanctl repo [-h | --help] [-l | --list] [-i | --init <repository>] [--rm <repository>] [-o | --open <repository>] [-c | --close <repository>]"

        # NOTE turn CRUD operations into subcommands? restructure to <repo> [option1, opt2...]? what's nice about this is you can issue multiple commands at once over ssh

        [ $# -eq 0 ] && echo $repo_usage && exit

        while [ $# -gt 0 ]; do
                case "$1" in
                        --help|-h)
                                echo $repo_usage
                                exit
                                ;;

                        --list|-l)
                                repo_list
                                exit
                                ;;

                        --init|-i)
                                repo_init "$2"
                                shift 2
                                ;;

                        --rm)
                                repo_rm "$2"
                                shift 2
                                ;;

                        --open|-o)
                                repo_open "$2"
                                shift 2
                                ;;

                        --close|-c)
                                repo_close "$2"
                                shift 2
                                ;;
                        
                        *)
                                echo $repo_usage
                                die 1 "Error: Unknown opt $1"
                                ;;
                esac
        done
}

# Auth functions
auth_list() {
        # Pretty prints the authorized key file
        # FIXME do the pretty part
        cat $GIT_DIR/.ssh/authorized_keys
}

auth_add() {
        #Adds a key to the authorized_keys file if it does not exist
        echo ""
        # if key is not in file
        # echo "no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ${key}" >> authorized_keys
}

auth_rm() {
        # Removes a specified key from the key file so long as it is not the current in use key
        local pattern="$1"
        local removed_lines="$(cat $GIT_DIR/.ssh/authorized_keys | grep "$pattern")"
        local removed_keys="$(echo "$removed_lines" | perl -nge '/(ssh-\w+ .+ .+)/; print $1')"
        local ssh_user_key="$(cat $SSH_USER_AUTH | perl -nge '/(ssh-\w+ .+)/; print $1')"

        echo "$removed_lines" > $GIT_DIR/.ssh/removed_keys

        if [[ "$removed_keys" == *"$ssh_user_key"* ]]; then
                die 1 "Anti-lockout: A session cannot remove the key it used to connect. Login with a different pubkey to delete this key."
        else
                echo "Pattern ${pattern} matched the following keys:"
                echo "$removed_keys"
                confirm "OK to remove these keys?" && \
                echo "$(grep -vxF -f $GIT_DIR/.ssh/removed_keys $GIT_DIR/.ssh/authorized_keys)" > $GIT_DIR/.ssh/authorized_keys
        fi
}

auth() {
        # Handles "auth" subcommand
        local auth_usage="vulcanctl auth [-h | --help] [-l | --list] [-a | --add <key>] [--rm <pattern>]"

        [ $# -eq 0 ] && echo "$auth_usage" && exit

        while [ $# -gt 0 ]; do
                case "$1" in
                        --help|-h)
                                echo "$auth_usage"
                                exit
                                ;;

                        --list|-l)
                                auth_list
                                exit
                                ;;

                        --add|-a)
                                auth_add "$2"
                                shift 2
                                ;;

                        --rm)
                                auth_rm "$2"
                                shift 2
                                ;;
                        
                        *)
                                echo "$auth_usage"
                                die 1 "Error: Unknown opt $1"
                                ;;
                esac
        done
}

# Main parse
[ $# -eq 0 ] && echo $USAGE && exit

case "$1" in
        --help|-h)
                echo "$USAGE"
                exit
                ;;

        repo)
                shift
                repo "$@"
                exit
                ;;

        auth)
                shift
                auth "$@"
                exit
                ;;
        
        *)
                echo "$USAGE"
                die 1 "Error: Unknown subcommand $1"
                ;;
esac